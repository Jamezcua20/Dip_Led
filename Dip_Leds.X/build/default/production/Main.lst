CCS PCH C Compiler, Version 5.081, 13314               22-ene.-26 02:40

               Filename:   C:\Users\pepec\Documents\Act_2\Dip_Leds.X\build\default\production\Main.lst

               ROM used:   1048 bytes (1%)
                           Largest free fragment is 65536
               RAM used:   21 (1%) at main() level
                           26 (1%) worst case
               Stack used: 0 locations
               Stack size: 31

*
00600:  GOTO   08F6
.................... /* 
....................  Autor: José Amezcua 
....................  Repositorio - Control de leds por Dip Protolink EX 
....................   
....................  * Pines Leds: PIN_B0,PIN_B1,PIN_E5,PIN_E4 
....................  * Pines Dip: PIN_F0, PIN_F1, PIN_F2, PIN_F3 
....................  * Pines serial: PIN_E2, PIN_E3 
....................   
....................  * Mapeo realizado por excore.h 
....................   
....................  UART 
....................  #define TX_5        PIN_E2 
....................  #define RX_5        PIN_E3 
....................  
....................  DIP 
....................  #define ADDR0       PIN_F0 
....................  #define ADDR1       PIN_F1 
....................  #define ADDR2       PIN_F2 
....................  #define ADDR3       PIN_F3 
....................  
....................  Leds 
....................  #define GPIO_1      PIN_B0 
....................  #define GPIO_2      PIN_B1 
....................  #define GPIO_3      PIN_E5 
....................  #define GPIO_4      PIN_E4 
....................  */ 
....................  
.................... #include "../protolink/excore.h" 
.................... /*  
....................  * File:   excore.h 
....................  * Author: Arturo Gasca 
....................  * Galio Electronics 
....................  * Excore V1 Pinout 
....................  * 
....................  * Created on 12 de noviembre de 2025, 08:25 PM 
....................  */ 
....................  
.................... #ifndef PROTOLINK_H 
.................... #define	PROTOLINK_H 
....................  
.................... #include <18F67K40.h>          // Ajusta tu MCU 
.................... //////////// Standard Header file for the PIC18F67K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F67K40 
*
00608:  DATA 56,61
0060A:  DATA 6C,6F
0060C:  DATA 72,20
0060E:  DATA 44,49
00610:  DATA 50,3A
00612:  DATA 20,25
00614:  DATA 75,20
00616:  DATA 0D,0A
00618:  DATA 00,00
0061A:  DATA 56,61
0061C:  DATA 6C,6F
0061E:  DATA 72,20
00620:  DATA 62,69
00622:  DATA 6E,61
00624:  DATA 72,69
00626:  DATA 6F,3A
00628:  DATA 20,00
0062A:  DATA 20,0D
0062C:  DATA 0A,00
*
007CE:  TBLRD*+
007D0:  MOVFF  FF6,15
007D4:  MOVFF  FF7,16
007D8:  MOVFF  FF8,17
007DC:  MOVF   FF5,W
007DE:  MOVLB  E
007E0:  BTFSS  x37.4
007E2:  BRA    07E0
007E4:  MOVWF  xDD
007E6:  MOVFF  15,FF6
007EA:  MOVFF  16,FF7
007EE:  MOVFF  17,FF8
007F2:  DECFSZ 14,F
007F4:  BRA    07F8
007F6:  BRA    07FC
007F8:  MOVLB  0
007FA:  BRA    07CE
007FC:  MOVLB  0
007FE:  RETURN 0
00800:  MOVF   18,W
00802:  CLRF   01
00804:  SUBWF  17,W
00806:  BC    080E
00808:  MOVFF  17,00
0080C:  BRA    0826
0080E:  CLRF   00
00810:  MOVLW  08
00812:  MOVWF  19
00814:  RLCF   17,F
00816:  RLCF   00,F
00818:  MOVF   18,W
0081A:  SUBWF  00,W
0081C:  BTFSC  FD8.0
0081E:  MOVWF  00
00820:  RLCF   01,F
00822:  DECFSZ 19,F
00824:  BRA    0814
00826:  RETURN 0
00828:  MOVF   01,W
0082A:  MOVFF  15,17
0082E:  MOVLW  64
00830:  MOVWF  18
00832:  RCALL  0800
00834:  MOVFF  00,15
00838:  MOVF   01,W
0083A:  MOVLW  30
0083C:  BNZ   084C
0083E:  BTFSS  16.1
00840:  BRA    0860
00842:  BTFSC  16.3
00844:  BRA    0860
00846:  BTFSC  16.4
00848:  MOVLW  20
0084A:  BRA    0852
0084C:  BCF    16.3
0084E:  BCF    16.4
00850:  BSF    16.0
00852:  ADDWF  01,F
00854:  MOVF   01,W
00856:  MOVLB  E
00858:  BTFSS  x37.4
0085A:  BRA    0858
0085C:  MOVWF  xDD
0085E:  MOVLB  0
00860:  MOVFF  15,17
00864:  MOVLW  0A
00866:  MOVWF  18
00868:  RCALL  0800
0086A:  MOVFF  00,15
0086E:  MOVF   01,W
00870:  MOVLW  30
00872:  BNZ   0880
00874:  BTFSC  16.3
00876:  BRA    088E
00878:  BTFSS  16.0
0087A:  BRA    088E
0087C:  BTFSC  16.4
0087E:  MOVLW  20
00880:  ADDWF  01,F
00882:  MOVF   01,W
00884:  MOVLB  E
00886:  BTFSS  x37.4
00888:  BRA    0886
0088A:  MOVWF  xDD
0088C:  MOVLB  0
0088E:  MOVLW  30
00890:  ADDWF  15,F
00892:  MOVF   15,W
00894:  MOVLB  E
00896:  BTFSS  x37.4
00898:  BRA    0896
0089A:  MOVWF  xDD
0089C:  MOVLB  0
0089E:  RETURN 0
008A0:  TBLRD*+
008A2:  MOVF   FF5,F
008A4:  BZ    08CC
008A6:  MOVFF  FF6,14
008AA:  MOVFF  FF7,15
008AE:  MOVFF  FF8,16
008B2:  MOVF   FF5,W
008B4:  MOVLB  E
008B6:  BTFSS  x37.4
008B8:  BRA    08B6
008BA:  MOVWF  xDD
008BC:  MOVFF  14,FF6
008C0:  MOVFF  15,FF7
008C4:  MOVFF  16,FF8
008C8:  MOVLB  0
008CA:  BRA    08A0
008CC:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC = 10 
.................... #fuses HS 
.................... #use delay(crystal=16mhz,clock=64mhz) 
008CE:  CLRF   FEA
008D0:  MOVLW  14
008D2:  MOVWF  FE9
008D4:  MOVF   FEF,W
008D6:  BZ    08F4
008D8:  MOVLW  14
008DA:  MOVWF  01
008DC:  CLRF   00
008DE:  DECFSZ 00,F
008E0:  BRA    08DE
008E2:  DECFSZ 01,F
008E4:  BRA    08DC
008E6:  MOVLW  BF
008E8:  MOVWF  00
008EA:  DECFSZ 00,F
008EC:  BRA    08EA
008EE:  BRA    08F0
008F0:  DECFSZ FEF,F
008F2:  BRA    08D8
008F4:  RETURN 0
....................  
.................... /*USER BUTTON AND LEDS*/ 
.................... #define USER        PIN_B2  //Interruption 2 
.................... #define LED1        PIN_D0 
....................  
....................  
.................... /*HEADER RS232*/ 
.................... #define TX_2        PIN_G1  //Puerto 1 UART2 
.................... #define RX_2        PIN_G2 
.................... #define TX_3        PIN_E0  //Puerto 2 UART3 
.................... #define RX_3        PIN_E1  
....................  
.................... /*HEADER RS485*/ 
.................... #define TX_4        PIN_C0  //UART4  
.................... #define RX_4        PIN_C1 
.................... #define TX_ENABLE   PIN_H0  //Internal Auxiliar 
.................... #define RX_ENABLE   PIN_H1  //Internal Auxiliar 
....................  
.................... /*USB SERIAL*/ 
.................... #define TX_5        PIN_E2  //UART5 
.................... #define RX_5        PIN_E3 
....................  
.................... /*DIP SWITCH*/ 
.................... #define ADDR0       PIN_F0 
.................... #define ADDR1       PIN_F1 
.................... #define ADDR2       PIN_F2 
.................... #define ADDR3       PIN_F3 
....................  
.................... #define PIN_SDA     PIN_C4 
.................... #define PIN_SCL     PIN_C3 
....................  
.................... #define GPIO_1      PIN_B0 
.................... #define GPIO_2      PIN_B1 
.................... #define GPIO_3      PIN_E5 
.................... #define GPIO_4      PIN_E4 
....................  
.................... //UART2 
.................... #pin_select U2TX=TX_2 
.................... #pin_select U2RX=RX_2 
....................  
.................... //UART3 
.................... #pin_select U3TX=TX_3 
.................... #pin_select U3RX=RX_3 
....................  
.................... //UART4 
.................... #pin_select U4TX=TX_4 
.................... #pin_select U4RX=RX_4 
....................  
.................... //UART5 
.................... #pin_select U5TX=TX_5 
.................... #pin_select U5RX=RX_5 
....................  
.................... //I2C1 
.................... #pin_select SCL1IN=PIN_SCL 
.................... #pin_select SDA1IN=PIN_SDA 
.................... // 
.................... // 
.................... ////SMT 
.................... #pin_select SMT1SIG = PIN_E7   // SMT1 
.................... #pin_select SMT2SIG = PIN_G7   // SMT2 
....................  
.................... //DEBUG SERIAL 
.................... #use rs232(baud=115200,parity=N,UART5,bits=8,stream=DEBUG,errors) 
....................  
.................... #define protolink_debug_msg(msg) fprintf(DEBUG, msg) 
.................... #define protolink_debug_data(msg,data) fprintf(DEBUG,msg,data) 
....................  
.................... void protolink_io_init(void) 
.................... { 
....................    // Primero todo como entrada (safe mode) 
....................    set_tris_a(0xFF);   // si no usas A, dejalo asi 
....................    set_tris_b(0b11111100);   // B todo entrada, B0 y B1 como salida) 
....................     
....................    // C: UART1, UART4, I2C 
....................    set_tris_c(0b10111110);   // C7 RX1 in, C6 TX1 out, C1 RX4 in, C0 TX4 out, SCL/SDA in 
....................  
....................    // D: salidas ULN2003 + ETH_RST 
....................    set_tris_d(0b01110000);   // D3..D0 out, D7 out, D6..D4 in 
....................  
....................    // E: UART3, UART5, entradas opto 
....................    set_tris_e(0b11001010);   // E0/E2, E4,E5 out, resto in 
....................  
....................    // F: LEDs + GPIO + ADC_RDY 
....................    set_tris_f(0b11111111);   // all out 
....................  
....................    // G: UART2 + EEPROM WP 
....................    set_tris_g(0b11111101);   // G1 TX2 out, G2 RX2 in, G7 SMT2 in 
....................  
....................    // H: control RS485 
....................    set_tris_h(0b11111100);   // H0/H1 out, resto in 
....................     
....................    output_float(PIN_SDA); 
....................    output_float(PIN_SCL); 
.................... } 
....................  
.................... #ifdef PROTOLINK_DEFAULT 
....................  
....................  
....................  
.................... /* Protolink Default functions 
....................  * Active define for use in main 
....................  * Interrupts use for counters INT0, INT1 
....................  * SMT1 and SMT use for counters 
....................  * Timer0 config for 1 second, consume in protolink_one_second() 
....................  */ 
.................... // Numero de interrupciones de TIMER0 para ~1 segundo 
.................... // 2.048 ms * 488 ? 999.424 ms 
.................... int16 NInts = 488; 
....................  
.................... // VARIABLES GLOBALES 
.................... int16 C_Ints = 0;   // Contador de interrupciones ocurridas 
.................... int1 Flag = 0;     // Flag que cambia cada ~1 segundo 
....................  
.................... // Ejemplo de uso: hacer algo cada vez que cambie Flag (~1s) 
.................... int1 lastFlag = 0; 
....................  
....................  
....................  
.................... volatile unsigned int32 flow1_smt_pps = 0;   // Pulsos/s medidos por SMT1 
.................... volatile unsigned int32 flow2_smt_pps = 0;   // Pulsos/s medidos por SMT2 
....................  
....................  
.................... // ---- CONTADORES ---- 
.................... volatile unsigned int32 flow1_counter = 0;      // Conteo total por INT0 
.................... volatile unsigned int32 flow2_counter = 0;      // Conteo total por INT1 
....................  
.................... volatile unsigned int32 flow1_pps = 0;          // Pulsos por segundo (INT0) 
.................... volatile unsigned int32 flow2_pps = 0;          // Pulsos por segundo (INT1) 
....................  
.................... #INT_TIMER0 
.................... void TIMER0_isr(void){ 
....................     // Incrementamos primero 
....................     C_Ints++; 
....................  
....................     if(C_Ints >= NInts) 
....................     { 
....................         C_Ints = 0; 
....................         Flag = !Flag;   // Toggle cada ~1s 
....................          
.................... //        static unsigned int32 last1 = 0; 
.................... //        static unsigned int32 last2 = 0; 
.................... //        unsigned int32 c1 = flow1_counter; 
.................... //        unsigned int32 c2 = flow2_counter; 
.................... //        flow1_pps = c1 - last1; 
.................... //        flow2_pps = c2 - last2; 
.................... //        last1 = c1; 
.................... //        last2 = c2; 
.................... //         
.................... //         // --- SMT1 / SMT2 --- 
.................... //        static unsigned int32 smt1_last = 0; 
.................... //        static unsigned int32 smt2_last = 0; 
.................... // 
.................... //        unsigned int32 smt1_now = smt1_read(SMT_TMR_REG); 
.................... //        unsigned int32 smt2_now = smt2_read(SMT_TMR_REG); 
.................... // 
.................... //        flow1_smt_pps = smt1_now - smt1_last; 
.................... //        flow2_smt_pps = smt2_now - smt2_last; 
.................... // 
.................... //        smt1_last = smt1_now; 
.................... //        smt2_last = smt2_now; 
....................     } 
....................     clear_interrupt(INT_TIMER0); 
....................      
....................  
.................... } 
....................  
.................... //// ---- ISR INTERRUPCIONES EXTERNAS ---- 
.................... //#INT_EXT            // INT0 
.................... //void isr_int0(void) 
.................... //{ 
.................... //   flow1_counter++; 
.................... //} 
.................... // 
.................... //#INT_EXT1           // INT1 
.................... //void isr_int1(void) 
.................... //{ 
.................... //   flow2_counter++; 
.................... //} 
....................  
.................... //Init default timer 0 for 1 second 
.................... void protolink_timer0_init(void){ 
....................     // Timer0 interno, 8 bits, prescaler 1:128 
....................     // (Las etiquetas pueden ser T0_* o RTCC_* segun version CCS) 
....................     setup_timer_0(T0_INTERNAL | T0_DIV_128 | T0_8_BIT); 
....................  
....................     C_Ints = 0; 
....................     Flag = 0; 
....................  
....................     clear_interrupt(INT_TIMER0); 
....................     enable_interrupts(INT_TIMER0); 
....................     enable_interrupts(GLOBAL); 
....................     set_timer0(0); 
....................      
.................... } 
.................... //Init default Interrupts for protolink 
.................... void protolink_interrupts_init(void){ 
....................     // INT0 en flanco de subida 
....................     ext_int_edge(0, L_TO_H); 
....................  
....................     // INT1 en flanco de subida 
....................     ext_int_edge(1, L_TO_H); 
....................  
....................     clear_interrupt(INT_EXT); 
....................     clear_interrupt(INT_EXT1); 
....................  
....................     enable_interrupts(INT_EXT); 
....................     enable_interrupts(INT_EXT1); 
....................      
.................... } 
....................  
.................... //void protolink_smt_init(void) 
.................... //{ 
.................... // 
.................... // 
.................... //   // ---- SMT1 como contador de pulsos en FLOW1_PIN (INT0) ---- 
.................... //   
.................... //   setup_smt1( 
.................... //           SMT_ENABLED  
.................... //           | SMT_TMR_ROLLSOVER          // 0, opcional, lo dejamos "por claridad" 
.................... //           | SMT_SIG_ACTIVE_HIGH        // 0, seï¿½al activa en alto 
.................... //           | SMT_TMR_INCREMENTS_ON_RE   // 0, flanco de subida 
.................... //           | SMT_DIV_BY_1               // 0 
.................... //           | SMT_REPEAT_DATA_ACQ_MODE   // 0x4000, adquisiciï¿½n continua 
.................... //           | SMT_MODE_COUNTER           // 0x0800, modo contador 
.................... //           | SMT_CLK_FOSC_DIV_4         // 0, vale para tenerlo explï¿½cito 
.................... //           | SMT_START_NOW              // arranca inmediatamente 
.................... //           ); 
.................... //   smt1_reset_timer();                     // contador = 0 
.................... // 
.................... //   // ---- SMT2 como contador de pulsos en FLOW2_PIN (INT1) ---- 
.................... //    
.................... //   setup_smt2( 
.................... //           SMT_ENABLED  
.................... //           | SMT_TMR_ROLLSOVER          // 0, opcional, lo dejamos "por claridad" 
.................... //           | SMT_SIG_ACTIVE_HIGH        // 0, seï¿½al activa en alto 
.................... //           | SMT_TMR_INCREMENTS_ON_RE   // 0, flanco de subida 
.................... //           | SMT_DIV_BY_1               // 0 
.................... //           | SMT_REPEAT_DATA_ACQ_MODE   // 0x4000, adquisiciï¿½n continua 
.................... //           | SMT_MODE_COUNTER           // 0x0800, modo contador 
.................... //           | SMT_CLK_FOSC_DIV_4         // 0, vale para tenerlo explï¿½cito 
.................... //           | SMT_START_NOW              // arranca inmediatamente 
.................... //           ); 
.................... //   smt2_reset_timer(); 
.................... //} 
.................... int1 protolink_one_second(void){ 
....................     if(Flag != lastFlag){ 
....................         lastFlag = flag; 
....................         return true; 
....................     } 
....................     return false; 
.................... } 
.................... #endif 
.................... #define LOADER_END   0x5FF  //ajuste de memoria para protolink v2 bootloader 
.................... #endif	/* PROTOLINK_H */ 
....................  
....................  
.................... #include <bootloader.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                       BOOTLOADER.H                                //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example bootloader (ex_bootloader.c).                     //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  LOADER_END may need to be adjusted for a specific chip and       //// 
.................... ////  bootloader.  LOADER_END must be 1 minus a multiple of            //// 
.................... ////  FLASH_ERASE_SIZE.                                                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2014 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __BOOTLOADER_H__ 
.................... #define __BOOTLOADER_H__ 
....................  
.................... #ifndef LOADER_END 
....................  #if defined(__PCM__) 
....................   #ifdef BOOTLOADER_MODE2X 
....................    #define LOADER_END 0x4BF 
....................   #else 
....................    #define LOADER_END 0x33F 
....................   #endif 
....................  #elif defined(__PCH__) 
....................   #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................   #if ((0x500 % FLASH_SIZE) == 0)         //IF 0x500 is even flash boundary 
....................    #define LOADER_END   0x4FF 
....................   #else                                  //ELSE, goto next even boundary 
....................    #define LOADER_END   ((0x500+FLASH_SIZE-(0x500 % FLASH_SIZE))-1) 
....................   #endif 
....................  #else 
....................   #error Bootloader only works with PCM or PCH compiler 
....................  #endif 
.................... #endif 
....................  
.................... #define LOADER_SIZE   LOADER_END 
....................  
.................... #ifndef BOOTLOADER_AT_START 
....................  #define BOOTLOADER_AT_START 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  #if defined(__PCM__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+5) 
....................  #elif defined(__PCH__) 
....................   #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  #endif 
....................  
....................  #org 0, LOADER_END {} 
.................... #else 
....................  #ifdef __PCM__ 
....................   #if getenv("PROGRAM_MEMORY") <= 0x800 
....................    #org LOADER_END+3, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+3, 0x7FF {} 
....................    #if getenv("PROGRAM_MEMORY") <= 0x1000 
....................     #org 0x800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................    #else 
....................     #org 0x800, 0xFFF{} 
....................     #if getenv("PROGRAM_MEMORY") <= 0x1800 
....................      #org 0x1000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................     #else 
....................      #org 0x1000, 0x17FF {} 
....................      #if getenv("PROGRAM_MEMORY") <= 0x2000 
....................       #org 0x1800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................      #else 
....................       #org 0x1800, 0x1FFF {} 
....................       #if getenv("PROGRAM_MEMORY") <= 0x2800 
....................        #org 0x2000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................       #else 
....................        #org 0x2000, 0x27FF {} 
....................        #if getenv("PROGRAM_MEMORY") <= 0x3000 
....................         #org 0x2800, (getenv("PROGRAM_MEMORY") - 1) {} 
....................        #else 
....................         #org 0x2800, 0x2FFF {} 
....................         #if getenv("PROGRAM_MEMORY") <= 0x3800 
....................          #org 0x3000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................         #else 
....................          #org 0x3000, 0x37FF {} 
....................          #org 0x3800, 0x3FFF {} 
....................         #endif 
....................        #endif 
....................       #endif 
....................      #endif 
....................     #endif 
....................    #endif 
....................   #endif 
....................  #else 
....................   #if getenv("PROGRAM_MEMORY") <= 0x10000 
....................    #org LOADER_END+5, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #else 
....................    #org LOADER_END+5, 0xFFFE {} 
....................    #org 0x10000, (getenv("PROGRAM_MEMORY") - 1) {} 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... int dip; 
.................... int8 bin[4]; 
....................  
.................... /* 
....................   
....................  El "~" se usa para negar el comportamiento del Switch (NOT). 
....................   
....................  El uso de 0x0F (binario 00001111) funciona como una máscara de bits que filtra 
....................  el puerto para obtener únicamente los 4 bits menos significativos 
....................  */ 
....................  
.................... void lectura(){ 
....................       dip = (input_f()) & 0x0F; 
*
0062E:  SETF   F86
00630:  MOVF   F8E,W
00632:  ANDLW  0F
00634:  MOVWF  0B
00636:  GOTO   098E (RETURN)
....................  //   dip = (~input_f()) & 0x0F; 
.................... } 
....................  
.................... void control_leds(){ 
....................     switch (dip){ 
0063A:  MOVF   0B,W
0063C:  XORLW  01
0063E:  BZ    0680
00640:  XORLW  03
00642:  BZ    0692
00644:  XORLW  01
00646:  BZ    06A4
00648:  XORLW  07
0064A:  BZ    06B6
0064C:  XORLW  01
0064E:  BZ    06C8
00650:  XORLW  03
00652:  BZ    06DA
00654:  XORLW  01
00656:  BZ    06EC
00658:  XORLW  0F
0065A:  BZ    06FE
0065C:  XORLW  01
0065E:  BZ    0710
00660:  XORLW  03
00662:  BZ    0722
00664:  XORLW  01
00666:  BZ    0734
00668:  XORLW  07
0066A:  BZ    0746
0066C:  XORLW  01
0066E:  BTFSC  FD8.2
00670:  BRA    0758
00672:  XORLW  03
00674:  BTFSC  FD8.2
00676:  BRA    076A
00678:  XORLW  01
0067A:  BTFSC  FD8.2
0067C:  BRA    077C
0067E:  BRA    078E
....................       case 1:   
....................        output_high(GPIO_1); 
00680:  BCF    F82.0
00682:  BSF    F7A.0
....................        output_low(GPIO_2); 
00684:  BCF    F82.1
00686:  BCF    F7A.1
....................        output_low(GPIO_3); 
00688:  BCF    F85.5
0068A:  BCF    F7D.5
....................        output_low(GPIO_4); 
0068C:  BCF    F85.4
0068E:  BCF    F7D.4
....................        break;   
00690:  BRA    079E
....................  
....................       case 2:   
....................        output_low(GPIO_1); 
00692:  BCF    F82.0
00694:  BCF    F7A.0
....................        output_high(GPIO_2); 
00696:  BCF    F82.1
00698:  BSF    F7A.1
....................        output_low(GPIO_3); 
0069A:  BCF    F85.5
0069C:  BCF    F7D.5
....................        output_low(GPIO_4); 
0069E:  BCF    F85.4
006A0:  BCF    F7D.4
....................        break;   
006A2:  BRA    079E
....................  
....................       case 3:   
....................        output_high(GPIO_1); 
006A4:  BCF    F82.0
006A6:  BSF    F7A.0
....................        output_high(GPIO_2); 
006A8:  BCF    F82.1
006AA:  BSF    F7A.1
....................        output_low(GPIO_3); 
006AC:  BCF    F85.5
006AE:  BCF    F7D.5
....................        output_low(GPIO_4); 
006B0:  BCF    F85.4
006B2:  BCF    F7D.4
....................        break;   
006B4:  BRA    079E
....................  
....................       case 4:   
....................        output_low(GPIO_1); 
006B6:  BCF    F82.0
006B8:  BCF    F7A.0
....................        output_low(GPIO_2); 
006BA:  BCF    F82.1
006BC:  BCF    F7A.1
....................        output_high(GPIO_3); 
006BE:  BCF    F85.5
006C0:  BSF    F7D.5
....................        output_low(GPIO_4); 
006C2:  BCF    F85.4
006C4:  BCF    F7D.4
....................        break;   
006C6:  BRA    079E
....................  
....................       case 5:   
....................        output_high(GPIO_1); 
006C8:  BCF    F82.0
006CA:  BSF    F7A.0
....................        output_low(GPIO_2); 
006CC:  BCF    F82.1
006CE:  BCF    F7A.1
....................        output_high(GPIO_3); 
006D0:  BCF    F85.5
006D2:  BSF    F7D.5
....................        output_low(GPIO_4); 
006D4:  BCF    F85.4
006D6:  BCF    F7D.4
....................        break;   
006D8:  BRA    079E
....................  
....................       case 6:   
....................        output_low(GPIO_1); 
006DA:  BCF    F82.0
006DC:  BCF    F7A.0
....................        output_high(GPIO_2); 
006DE:  BCF    F82.1
006E0:  BSF    F7A.1
....................        output_high(GPIO_3); 
006E2:  BCF    F85.5
006E4:  BSF    F7D.5
....................        output_low(GPIO_4); 
006E6:  BCF    F85.4
006E8:  BCF    F7D.4
....................        break;   
006EA:  BRA    079E
....................  
....................       case 7:   
....................        output_high(GPIO_1); 
006EC:  BCF    F82.0
006EE:  BSF    F7A.0
....................        output_high(GPIO_2); 
006F0:  BCF    F82.1
006F2:  BSF    F7A.1
....................        output_high(GPIO_3); 
006F4:  BCF    F85.5
006F6:  BSF    F7D.5
....................        output_low(GPIO_4); 
006F8:  BCF    F85.4
006FA:  BCF    F7D.4
....................        break;   
006FC:  BRA    079E
....................  
....................       case 8:   
....................        output_low(GPIO_1); 
006FE:  BCF    F82.0
00700:  BCF    F7A.0
....................        output_low(GPIO_2); 
00702:  BCF    F82.1
00704:  BCF    F7A.1
....................        output_low(GPIO_3); 
00706:  BCF    F85.5
00708:  BCF    F7D.5
....................        output_high(GPIO_4); 
0070A:  BCF    F85.4
0070C:  BSF    F7D.4
....................        break;   
0070E:  BRA    079E
....................  
....................       case 9:   
....................        output_high(GPIO_1); 
00710:  BCF    F82.0
00712:  BSF    F7A.0
....................        output_low(GPIO_2); 
00714:  BCF    F82.1
00716:  BCF    F7A.1
....................        output_low(GPIO_3); 
00718:  BCF    F85.5
0071A:  BCF    F7D.5
....................        output_high(GPIO_4); 
0071C:  BCF    F85.4
0071E:  BSF    F7D.4
....................        break;   
00720:  BRA    079E
....................  
....................       case 10:   
....................        output_low(GPIO_1); 
00722:  BCF    F82.0
00724:  BCF    F7A.0
....................        output_high(GPIO_2); 
00726:  BCF    F82.1
00728:  BSF    F7A.1
....................        output_low(GPIO_3); 
0072A:  BCF    F85.5
0072C:  BCF    F7D.5
....................        output_high(GPIO_4); 
0072E:  BCF    F85.4
00730:  BSF    F7D.4
....................        break;   
00732:  BRA    079E
....................  
....................       case 11:   
....................        output_high(GPIO_1); 
00734:  BCF    F82.0
00736:  BSF    F7A.0
....................        output_high(GPIO_2); 
00738:  BCF    F82.1
0073A:  BSF    F7A.1
....................        output_low(GPIO_3); 
0073C:  BCF    F85.5
0073E:  BCF    F7D.5
....................        output_high(GPIO_4); 
00740:  BCF    F85.4
00742:  BSF    F7D.4
....................        break;   
00744:  BRA    079E
....................  
....................       case 12:   
....................        output_low(GPIO_1); 
00746:  BCF    F82.0
00748:  BCF    F7A.0
....................        output_low(GPIO_2); 
0074A:  BCF    F82.1
0074C:  BCF    F7A.1
....................        output_high(GPIO_3); 
0074E:  BCF    F85.5
00750:  BSF    F7D.5
....................        output_high(GPIO_4); 
00752:  BCF    F85.4
00754:  BSF    F7D.4
....................        break;   
00756:  BRA    079E
....................  
....................       case 13:   
....................        output_high(GPIO_1); 
00758:  BCF    F82.0
0075A:  BSF    F7A.0
....................        output_low(GPIO_2); 
0075C:  BCF    F82.1
0075E:  BCF    F7A.1
....................        output_high(GPIO_3); 
00760:  BCF    F85.5
00762:  BSF    F7D.5
....................        output_high(GPIO_4); 
00764:  BCF    F85.4
00766:  BSF    F7D.4
....................        break;   
00768:  BRA    079E
....................  
....................       case 14:   
....................        output_low(GPIO_1); 
0076A:  BCF    F82.0
0076C:  BCF    F7A.0
....................        output_high(GPIO_2); 
0076E:  BCF    F82.1
00770:  BSF    F7A.1
....................        output_high(GPIO_3); 
00772:  BCF    F85.5
00774:  BSF    F7D.5
....................        output_high(GPIO_4); 
00776:  BCF    F85.4
00778:  BSF    F7D.4
....................        break;   
0077A:  BRA    079E
....................  
....................       case 15:   
....................        output_high(GPIO_1); 
0077C:  BCF    F82.0
0077E:  BSF    F7A.0
....................        output_high(GPIO_2); 
00780:  BCF    F82.1
00782:  BSF    F7A.1
....................        output_high(GPIO_3); 
00784:  BCF    F85.5
00786:  BSF    F7D.5
....................        output_high(GPIO_4); 
00788:  BCF    F85.4
0078A:  BSF    F7D.4
....................        break;          
0078C:  BRA    079E
....................         
....................       default: 
....................          output_low(GPIO_1); 
0078E:  BCF    F82.0
00790:  BCF    F7A.0
....................          output_low(GPIO_2); 
00792:  BCF    F82.1
00794:  BCF    F7A.1
....................          output_low(GPIO_3); 
00796:  BCF    F85.5
00798:  BCF    F7D.5
....................          output_low(GPIO_4); 
0079A:  BCF    F85.4
0079C:  BCF    F7D.4
....................          break; 
....................           
....................     } 
0079E:  GOTO   0996 (RETURN)
.................... } 
....................  
.................... void binario() { 
007A2:  MOVFF  0B,14
....................     int x = dip; 
....................     for(int i = 0; i < 4; i++) { 
007A6:  CLRF   15
007A8:  MOVF   15,W
007AA:  SUBLW  03
007AC:  BNC   07CA
....................         bin[i] = x % 2;   
007AE:  CLRF   03
007B0:  MOVF   15,W
007B2:  ADDLW  0C
007B4:  MOVWF  FE9
007B6:  MOVLW  00
007B8:  ADDWFC 03,W
007BA:  MOVWF  FEA
007BC:  MOVF   14,W
007BE:  ANDLW  01
007C0:  MOVWF  FEF
....................         x = x / 2;        
007C2:  BCF    FD8.0
007C4:  RRCF   14,F
007C6:  INCF   15,F
007C8:  BRA    07A8
....................     } 
007CA:  GOTO   0998 (RETURN)
.................... } 
....................  
.................... void main (void){ 
*
008F6:  BSF    F77.7
008F8:  BCF    F77.6
008FA:  CLRF   FF8
008FC:  BCF    FF2.5
008FE:  MOVLB  E
00900:  MOVLW  55
00902:  MOVLB  D
00904:  MOVWF  xEF
00906:  MOVLW  AA
00908:  MOVWF  xEF
0090A:  BCF    xEF.0
0090C:  MOVLW  27
0090E:  MOVLB  E
00910:  MOVWF  x08
00912:  MOVLW  37
00914:  MOVWF  x0A
00916:  MOVLW  32
00918:  MOVWF  x11
0091A:  MOVLW  21
0091C:  MOVWF  x13
0091E:  MOVLW  11
00920:  MOVWF  x15
00922:  MOVLW  23
00924:  MOVWF  x17
00926:  MOVLW  13
00928:  MOVWF  x19
0092A:  MOVLW  14
0092C:  MOVWF  x1A
0092E:  MOVLW  12
00930:  MOVWF  x62
00932:  MOVLW  10
00934:  MOVWF  x72
00936:  MOVLW  14
00938:  MOVWF  x74
0093A:  MOVLW  0E
0093C:  MOVWF  x83
0093E:  MOVLW  55
00940:  MOVLB  D
00942:  MOVWF  xEF
00944:  MOVLW  AA
00946:  MOVWF  xEF
00948:  BSF    xEF.0
0094A:  MOVLB  E
0094C:  CLRF   x48
0094E:  CLRF   x45
00950:  CLRF   x47
00952:  CLRF   x49
00954:  MOVLW  20
00956:  MOVWF  x43
00958:  CLRF   04
0095A:  BSF    xE2.3
0095C:  MOVLW  8A
0095E:  MOVWF  xDE
00960:  MOVLW  00
00962:  MOVWF  xDF
00964:  MOVLW  A6
00966:  MOVWF  xE1
00968:  MOVLW  90
0096A:  MOVWF  xE0
0096C:  CLRF   11
0096E:  CLRF   10
00970:  CLRF   x92
00972:  CLRF   x9A
00974:  CLRF   xA7
00976:  CLRF   xAF
00978:  CLRF   xB4
0097A:  CLRF   xBC
0097C:  CLRF   xD2
0097E:  CLRF   xD3
00980:  CLRF   xD1
00982:  CLRF   xD0
00984:  CLRF   05
00986:  CLRF   06
00988:  CLRF   12
.................... int lectura_ant = 0; 
.................... while(1){ 
....................     lectura(); 
0098A:  MOVLB  0
0098C:  BRA    062E
....................     if(dip!= lectura_ant){ 
0098E:  MOVF   12,W
00990:  SUBWF  0B,W
00992:  BZ    0A12
....................     control_leds(); 
00994:  BRA    063A
....................     binario(); 
00996:  BRA    07A2
....................         protolink_debug_data("Valor DIP: %u \r\n", dip); 
00998:  MOVLW  08
0099A:  MOVWF  FF6
0099C:  MOVLW  06
0099E:  MOVWF  FF7
009A0:  MOVLW  00
009A2:  MOVWF  FF8
009A4:  MOVLW  0B
009A6:  MOVWF  14
009A8:  RCALL  07CE
009AA:  MOVFF  0B,15
009AE:  MOVLW  1B
009B0:  MOVWF  16
009B2:  RCALL  0828
009B4:  MOVLW  15
009B6:  MOVWF  FF6
009B8:  MOVLW  06
009BA:  MOVWF  FF7
009BC:  MOVLW  00
009BE:  MOVWF  FF8
009C0:  MOVLW  03
009C2:  MOVWF  14
009C4:  RCALL  07CE
....................         protolink_debug_msg("Valor binario: "); 
009C6:  MOVLW  1A
009C8:  MOVWF  FF6
009CA:  MOVLW  06
009CC:  MOVWF  FF7
009CE:  MOVLW  00
009D0:  MOVWF  FF8
009D2:  RCALL  08A0
....................         for(int z = 4; z > 0; z--){ 
009D4:  MOVLW  04
009D6:  MOVWF  13
009D8:  MOVF   13,F
009DA:  BZ    0A00
....................             protolink_debug_data("%u", bin[z-1]); 
009DC:  MOVLW  01
009DE:  SUBWF  13,W
009E0:  CLRF   03
009E2:  ADDLW  0C
009E4:  MOVWF  FE9
009E6:  MOVLW  00
009E8:  ADDWFC 03,W
009EA:  MOVWF  FEA
009EC:  MOVFF  FEF,15
009F0:  MOVLW  1B
009F2:  MOVWF  16
009F4:  RCALL  0828
....................             delay_ms(5); 
009F6:  MOVLW  05
009F8:  MOVWF  14
009FA:  RCALL  08CE
009FC:  DECF   13,F
009FE:  BRA    09D8
....................         } 
....................          
....................         protolink_debug_msg(" \r\n"); 
00A00:  MOVLW  2A
00A02:  MOVWF  FF6
00A04:  MOVLW  06
00A06:  MOVWF  FF7
00A08:  MOVLW  00
00A0A:  MOVWF  FF8
00A0C:  RCALL  08A0
....................         lectura_ant = dip; 
00A0E:  MOVFF  0B,12
....................     } 
....................      
....................     delay_ms(250); 
00A12:  MOVLW  FA
00A14:  MOVWF  14
00A16:  RCALL  08CE
00A18:  BRA    098C
.................... } 
.................... } 
00A1A:  SLEEP 

Configuration Fuses:
   Word  1: FFAA   HS RSTOSC_EXT_PLL NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
